### 1 01背包问题

#### 1.1 问题描述

有N件物品和一个容量为V的背包。放入第i件物品耗费的容量（或费用）为C[i]，得到的价值是W[i]。求解将哪些物品装入背包可使价值总和最大。

#### 1.2 基本思路

这是最基础的背包问题，特点：每种物品仅有一件，可以选择放或不放。

##### 1.2.1 状态转移方程

![func](img/func.png)

F[i,v]表示将前i件物品放出容量为v的背包中所得到的最大价值。对于01背包问题，我们可以将问题转化为只和前i-1件物品相关的问题，因此，现在只需考虑第i件物品的策略（放 or 不放）。因此F[i,v]的值应取max{不放，放}。

##### 1.2.2 伪代码

![code](img/code.png)

在这里算法的空间复杂度为O(VN)，可以继续优化成O(V)，但空间复杂度应该已经不能再优化了。其中最终问题的解即为F[N,V]

* 关于初始化：在伪代码的第一行，我们可以看到程序将F[0,0..V]，也就是第0行的值全部初始化为0，这里的实际意义也是很好理解的，因为F[i,v]代表将前i件物品放入容量为v的背包中所获得的最大价值，因此前0件物品不论放入容量多大的背包中其获得的价值都是为0的。

#### 1.3 优化空间复杂度

前面在1.2.2中提到，空间复杂度可以优化为O(V)，那我们如何使用一维的数组实现这个问题呢？

如果转化为使用一维数组F[V]，那么原本的F[i,v]即变成了F[v]，而F[i-1, v-C[i]]即变为F[v-C[i]]，但F[i-1,v]在一维数组中怎么表示呢？它明显是代表了前一行的数据，既然v的坐标是与等号前面相同的，那我们很容易的会联想到使用当前的F[v]作为原来的F[i-1, v]。但如此一来，第二个循环就需要变为降序，这样才能保证更新F[v]前的值为上一次外循环的值（也就是F[i-1,v]），同时保证了F[v-C[i]]也为上一次外循环产生的值（也就是F[i-1, v-C[i]]）。反过来一想，如果我们还是对内循环采用升序的话，会造成什么后果呢，在本次内循环更新前的F[v]的确是上一次外循环产生的值，但却会导致在下一个内循环中我们所要使用F[v-1]变为了本次外循环的值（我们用到的本应该是F[i-1, v-C[i]]）。因此状态转移公式就变成了F[i,v]是由F[i,v-C[i]]推导得到的，显然与本题意不符。

##### 1.3.1 伪代码

![code2](img/code2.png)

* 关于初始化：由于该数组要存储一次外循环所更新的值，因此在循环之前的初始化操作就需要得到将前0件物品放入背包容量为0到V时所得到的最大价值，所以初始化其值为0。

#### 1.4 一个常数优化

待续...

